#Homework4
#Q1
#What is the sequence of nodes (characters) generated by preorder tree traversal
#A B E H F I C D G
#What is the sequence of nodes (characters) generated by breadth-first tree traversal
#A B C D E F G H I
#What is the sequence of nodes (characters) generated by post tree traversal
#H E I F B C G D A
#Second Q1
#What is the sequence of nodes (characters) generated by in-order tree traversal
#G D B E A C H F I
#Q2
with open('input file name instead', 'r') as file:
    lines = file.read().splitlines()

n = int(lines[0])
target = int(lines[1])
array = list(map(int, lines[2].split()))

array.sort(reverse=True)

current_sum = 0
count = 0

for num in array:
    current_sum += num
    count += 1
    if current_sum > target:
        break

print(f"Input: {','.join(map(str, array))} Target: {target} Answer: {count}")
#Q3
def is_right_triangle(p1, p2, p3):
    def dot(u, v):
        return u[0]*v[0] + u[1]*v[1]
    AB = (p2[0] - p1[0], p2[1] - p1[1])
    AC = (p3[0] - p1[0], p3[1] - p1[1])
    BC = (p3[0] - p2[0], p3[1] - p2[1])
    return (
        dot(AB, AC) == 0 or
        dot(AB, BC) == 0 or
        dot(AC, BC) == 0
    )

with open('input file name instead', 'r') as f:
    lines = f.read().splitlines()

n = int(lines[0])
points = [tuple(map(int, line.split())) for line in lines[1:]]

count = 0
for i in range(n):
    for j in range(i+1, n):
        for k in range(j+1, n):
            if is_right_triangle(points[i], points[j], points[k]):
                count += 1

print(f"The number of right triangles is: {count}")

#Homework3
#Q1
def palindrome(p): # This uses recursion to check whether a string is a palindrome.
    if len(p) <= 1: # If the string has length 0 or 1, it’s trivially a palindrome.
        return True
    if p[0] != p[-1]: #This compares the first and last characters, if they’re different, it is not a palindrome.
        return False
    return palindrome(p[1:-1]) # Strip outer characters and check the inner substring

count = 0
with open("C:\BU Python\input_file.txt", "r") as file: # Before inputing any text file, I need to move the file to C:\BU Python folder. Then I change the "input_file" here to the actual file name.
    for line in file:
        word = line.strip()  # removes newline and spaces
        result = palindrome(word)
        print(str(result).lower()) # print "true" or "false" in lowr case
        if result:
            count += 1
print(count)

[Download the Word document](palendrome file test screen shot.docx)

#Q2
def collect_substrings(s, start, current, seen):
    if start >= len(s):  # Base case: stop if we've reached the end of the string
        return
    current += s[start] # Add the next character to the current substring
    if current not in seen: # If it's a new substring, print it and add to the set
        print(current)
        seen.add(current)
    collect_substrings(s, start + 1, current, seen) # move to the next character

def unique_substrings(s):
    seen = set()
    for i in range(len(s)): # Start recursion from every index
        collect_substrings(s, i, "", seen)
    print("Total unique substrings:", len(seen))
    return seen

unique_substrings("abcab")

#Q3
def insert_at_bottom(stack, item):
    if not stack:
        stack.append(item)
    else:
        temp = stack.pop()
        insert_at_bottom(stack, item)
        stack.append(temp)

def reverse_stack_array(stack):
    if stack:
        temp = stack.pop()
        reverse_stack_array(stack)
        insert_at_bottom(stack, temp)

#Linked List
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def reverse_linked_list(head):
    if head is None or head.next is None:
        return head  # Base case: last node becomes new head

    new_head = reverse_linked_list(head.next)
    head.next.next = head
    head.next = None
    return new_head
    
#Double Linked List
class DNode:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

def reverse_doubly_linked_list(node):
    if node is None:
        return None
    node.prev, node.next = node.next, node.prev  # Swap next and prev
    
    if node.prev is None: # If the original next was None, this node is the new head
        return node
    return reverse_doubly_linked_list(node.prev)




